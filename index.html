const WebSocket = require('ws');
const PORT = process.env.PORT || 3000;
const wss = new WebSocket.Server({ port: PORT });

const EVENTS = [ /* paste your full EVENTS array here exactly */ ];
const TARD_CARDS = [ /* paste your full TARD_CARDS array here */ ];
const CHARACTERS = [ /* paste your full CHARACTERS array */ ];
const FINISH_POS = EVENTS.length - 1;
const START_MONEY = 0;
const START_FAMILY = 0;

const games = new Map();

function shuffle(array) {
  for(let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function getRandomColor() {
  const colors = ['#e53935','#8e24aa','#3949ab','#00acc1','#43a047','#fb8c00','#il'#7b1fa2'];
  return colors[Math.floor(Math.random() * colors.length)];
}

wss.on('connection', ws => {
  let game = null;
  let playerId = null;

  ws.on('message', data => {
    const msg = JSON.parse(data);

    if(msg.type === 'joinGame') {
      let gameId = msg.gameId || null;
      const playerName = msg.playerName || 'Lowlife';

      if(!gameId) gameId = Math.random().toString(36).substring(2,8).toUpperCase();

      if(!games.has(gameId)) {
        games.set(gameId, {
          state: 'lobby',
          players: new Map(),
          deck: shuffle([...TARD_CARDS]),
          firstFinisher: null
        });
      }
      game = games.get(gameId);

      playerId = Math.random().toString(36).substring(2,12);
      game.players.set(playerId, {
        id: playerId,
        name: playerName,
        color: getRandomColor(),
        position: 0,
        money: START_MONEY,
        family: START_FAMILY,
        character: null,
        missedNextPayday: false,
        missedTurns: 0
      });

      ws.send(JSON.stringify({
        type: 'welcome',
        yourId: playerId,
        gameId,
        gameState: getGameState(game)
      }));

      broadcast(game, {type: 'gameUpdate', gameState: getGameState(game)});
    }

    if(msg.type === 'startGame' && game && game.state === 'lobby' && game.players.size >= 2) {
      game.state = 'playing';
      const chars = shuffle([...CHARACTERS]);
      let i = 0;
      for(let p of game.players.values()) {
        p.character = chars[i++ % chars.length];
        p.money = START_MONEY;
        p.family = START_FAMILY;
        p.missedNextPayday = false;
        p.missedTurns = 0;
      }
      game.turnIndex = Math.floor(Math.random() * game.players.size);
      game.turnPlayerId = Array.from(game.players.keys())[game.turnIndex];
      broadcast(game, {type: 'gameStarted', gameState: getGameState(game)});
    }

    if(msg.type === 'spin' && game && game.state === 'playing' && game.turnPlayerId === playerId && !game.currentRoll) {
      const roll = Math.floor(Math.random() * 10) + 1;
      game.currentRoll = roll;
      broadcast(game, {type: 'roll', playerId, roll});
      setTimeout(() => processMove(game, playerId, roll), 4500); // give client time to animate
    }
  });

  ws.on('close', () => {
    if(game && playerId) {
      game.players.delete(playerId);
      if(game.players.size === 0) games.delete(game.gameId || gameId);
      else broadcast(game, {type: 'gameUpdate', gameState: getGameState(game)});
    }
  });
});

function broadcast(game, msg) {
  game.players.forEach(p => p.ws?.send(JSON.stringify(msg)));
}

function getGameState(game) {
  const players = {};
  game.players.forEach(p => {
    players[p.id] = {
      id: p.id,
      name: p.name,
      color: p.color,
      character: p.character,
      position: p.position,
      money: p.money,
      family: p.family
    };
  });
  return {
    state: game.state,
    players,
    turn: game.turnPlayerId,
    deckCount: game.deck.length
  };
}

function processMove(game, playerId, roll) {
  const player = game.players.get(playerId);
  if(player.missedTurns > 0) {
    player.missedTurns--;
    broadcast(game, {type:'message', text: `${player.name} misses turn`});
    nextTurn(game);
    game.currentRoll = null;
    return;
  }

  if(player.missedNextPayday) player.missedNextPayday = false;

  player.position += roll;

  let text = EVENTS[player.position % EVENTS.length];
  let effects = [];

  // PAYDAY
  if(text.includes('Payday')) {
    if(!player.missedNextPayday) player.money += player.character.payday;
    else player.missedNextPayday = false;
    effects.push('Payday');
  }

  // SIMPLE MONEY
  const moneyMatch = text.match(/\$([\d,]+)/g);
  if(moneyMatch) {
    moneyMatch.forEach(m => {
      const amount = parseInt(m.slice(1).replace(',',''));
      if(text.includes('earn') || text.includes('win') || text.includes('found') || text.includes('bonus')) player.money += amount;
      else player.money -= amount;
    });
  }

  // FAMILY
  if(text.includes('gain a family member') || text.includes('gain 1 family member')) player.family += text.includes('twins') ? 2 : 1;
  if(text.includes('lose a family member')) player.family = Math.max(0, player.family -1);

  // VIRAL / TIMES 100
  if(text.includes('spin times 100') || text.includes('spin x 100')) player.money += roll * 100;

  // TARD CARD
  if(text.includes('Tard card')) {
    if(game.deck.length === 0) game.deck = shuffle([...TARD_CARDS]);
    const card = game.deck.pop();
    broadcast(game, {type:'tardCard', playerId, card});
    // apply simple card effects here too (payoff, family, etc)
    if(card.includes('Payoff Card')) {
      player.money -= roll * 50;
      game.players.forEach(p => {
        if(p.id !== playerId && p.character && player.character.paysOff.includes(p.character.name)) p.money += roll * 50;
      });
    }
    if(card.includes('lose 1 family member')) player.family = Math.max(0, player.family -1);
    if(card.includes('gain 1 family member')) player.family +=1;
    // etc - add more if you want
  }

  // LOTTERY
  if(text.includes('Lottery')) {
    const needed = text.match(/spin ([\d or ]+) to win/)?.[1]?.split(' or ').map(Number) || [];
    if(needed.includes(roll)) {
      player.money += roll * 200;
      effects.push('LOTTERY WIN! $' + roll*200);
    }
  }

  if(text.includes('Finish') && !game.firstFinisher) {
    player.money += 10000;
    game.firstFinisher = playerId;
    effects.push('FIRST TO FINISH â€” $10,000 BONUS!');
  }

  broadcast(game, {type:'gameUpdate', gameState: getGameState(game)});
  if(effects.length) broadcast(game, {type:'message', text: effects.join(', ')});

  game.currentRoll = null;
  nextTurn(game);
}

function nextTurn(game) {
  const ids = Array.from(game.players.keys());
  game.turnIndex = (game.turnIndex + 1) % ids.length;
  game.turnPlayerId = ids[game.turnIndex];
  broadcast(game, {type:'gameUpdate', gameState: getGameState(game)});
}

console.log(`Lowlife server running on port ${PORT}`);